data Press_Start_Text
{
    "PRESS START" 0
}

subroutine Initialise_Press_Start_Sprite_Data # Will generate 10 sprite chain
{
    # Y delta, X delta, and character
    word Destination : HL; # This will assign 32 bytes
    word Source : DE;
    byte Delta : C;

    B = $00;

    label Loop;
        A = B;
        A >>= 1;
        A += C;
        A >>= 1;
        A &= $0F;
        call Triangle_Wave;
        [HL++] = A;
        A = B;
        [HL++] = A;
        A += $09;
        B = A;

        A = [DE];
        A |= A;
        return zero;    # Will only terminate function once string null-terminator is reached
        DE++;
        [HL++] = A;
        A = [DE];
        A < " ";
    jump not_zero Loop;

    A = $10;
    A += B;
    B = A;
    DE++;

    jump Loop;
}

subroutine Check_Press_Start
{
    
}

subroutine Title_Screen_Loop
{
    #HL = Plush_Tile_Data;
    #D = $02;
    #BC = $070B;
    #call Get_Pixel;

    label Loop;

        BC = $3D44;
        push BC;
        BC = $0014;
        push BC;
        DE = Plush_Sprite_Data;
        call Place_Sprites_In_OAM;

        BC = $3D44;
        push BC;
        BC = $1002;
        push BC;
        DE = Plush_Eye_Whites_Data;
        call Place_Sprites_In_OAM;

        #HL = $CFFF;
        #[HL]++;
        #C = [HL];

        call Increment_Parallax_Scroll_Registers;

        A = [$FF00 + Frame_Counter];
        C = A;
        
        HL = $D000;
        DE = Press_Start_Text;
        call Initialise_Press_Start_Sprite_Data;


        BC = $7821;
        push BC;
        BC = $100A;
        push BC;
        DE = $D000;
        call Place_Sprites_In_OAM;

        label Wait_For_VBlank;
            A = [$FF00 + LCDY_REGISTER];
            A++;
            A < VBLANK_LY;
        jump not_zero Wait_For_VBlank;

        label Wait_For_VBlank_End;
            A = [$FF00 + LCDY_REGISTER];
            A++;
            A < VBLANK_LY;
        jump not_carry Wait_For_VBlank_End; # This waits until LCDY loops back around to 0

        call Clean_OAM_Buffer;

    jump Loop;

    # return;
}

subroutine Init_Title_Screen_Graphics
{
    HL = FNAF_World_Title_Tile_Map;
    BC = VRAM_TILEM_1;  # This is the 'window' tilemap

    A = $AE;
    E = $15;
    label Fill_Top_Row;
        [BC] = A;
        C++;
        E--;
    jump not_zero Fill_Top_Row;

    A = $0B;
    A += C;
    C = A;

    E = 3;    # 18 bytes
    D = $0F;

    label Load_Title_Tilemap;
        push DE;
        E = $09;
        A = $B0;
        [BC] = A;
        C++;
        label Load_Row;
            A = [HL];
            swap A;
            A &= D;     # Lower nibble
            A += $AE;   # Adds delta
            [BC] = A;
            C++;

            A = [HL++];
            A &= D;
            A += $AE;
            [BC] = A;
            C++;

            E--;
        jump not_zero Load_Row;
        A = $B0;
        [BC] = A;
        C++;
        [BC] = A;

        A = $0C;
        A += C;
        C = A;

        pop DE;
        E--;
    jump not_zero Load_Title_Tilemap;

    A = $AE;
    E = $15;
    label Fill_Bottom_Row;
        [BC] = A;
        C++;
        E--;
    jump not_zero Fill_Bottom_Row;

    #

    return;
}