file Audio_Test/Memory_Copy.low;

file Logo_Data.td;

file LOW_Macros.low;

data Placeholder $0200
{
    # No data
}

file Audio_Test/Test_Song.low;
file Audio_Test/Song_Interpreter.low;

data Song_Handle_Data
{
    high(Test_Song) Test_Song
    $00 $00 $00
}

subroutine Main_Loop
{
    HL = $FF20;
    A ^= A;
    [HL++] = A;
    A = $80;
    [HL++] = A;
    A = $70;
    [HL++] = A;
    A = $C0;
    [HL++] = A;

    
    HL = Song_Handle_Data;
    BC = $D000; # Nice free area in WRAM
    DE = $05;
    call Memcpy;    # This copies the sound handle data into memory

    label Audio_Loop;

    label Wait_For_VBlank;
        A = [$FF00 + LCDY_REGISTER];
        A < VBLANK_LY;
    jump not_zero Wait_For_VBlank;

    C = $10;    # Channel 1
    push BC;
    HL = $D000; # This is the pointer to the sound handle we created earlier
    call Channel_Sound_Handle_Function;
    SP += $02;  # We remove the local scope ourselves

    jump Audio_Loop;
}

file Audio_Test/Song_Interpreter.low;
file Audio_Test/Test_Song.low;

subroutine Main $0150
{
    HL = $CFFF;
    SP = HL;    # Sets stack pointer nicely

    A ^= A;
    [$FF00 + INTERRUPT_ENABLE_REGISTER] = A; # This disables all interrupts

    label Wait_For_VBlank;
    A = [$FF00 + LCDY_REGISTER];
    A < VBLANK_LY;
    jump not_zero Wait_For_VBlank;

    [$FF00 + LCDC_REGISTER] = A;    # Turns off the LCD

    A = $80;
    [$FF00 + $FF26] = A;    # Turns on the APU

    A = $FF;
    [$FF00 + $FF25] = A;

    A = $80;
    [$FF00 + LCDC_REGISTER] = A;

    jump Main_Loop;
}



subroutine Program_Entry $0100
{
    jump Main;
}