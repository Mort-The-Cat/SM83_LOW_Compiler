macro LCD_Interrupt_Routine_Flags $C0A0;
# This byte is used to tell the CPU which 
# LCD interrupt routine we should use

macro VBlank_Interrupt_Routine_Flags $C0A1;
# This byte is used to tell the CPU which
# VBlank interrupt routine we should use

macro Frame_Counter_Register $C0A2;

macro OAM_Buffer_Counter $C0A3;

#

macro Title_Text_Left_Pad_Graphics_Size $07;
data Title_Text_Left_Pad $1100
{
	$10 $00 $AE
	$18 $00 $B0
	$20 $00 $B0
	$28 $00 $B0
	$30 $00 $B0
	$38 $00 $B0
	$40 $00 $AF
}

subroutine Place_Meta_Sprite_In_OAM $1000
{
	# Before this function is called, push object Y and X to the stack.
	# Then, push sprite flags and the number of sprites to the stack

	# SP + $00 and SP + $01 are the return function pointer

	# SP + $02 is counter
	# SP + $03 is sprite flags
	# SP + $04 is the X value
	# SP + $05 is the Y value
	# SP + ... are important values we want to return to after the function

	# DE is the sprite information pointer
		# This includes delta X, delta Y, and tile
	# BC will be the destination pointer into the OAM buffer

	# HL will grab stuff off the stack for us

	BC = OAM_Buffer_Counter;
	A = [BC];
	HL = SP + $02;	# Counter value
	H = [HL];		# Gets counter
	L = A;			# Saves current OAM buffer counter
	A += H;			# Increments OAM buffer counter by the counter
	[BC] = A;		# Saves that value
	C = L;			# BC is the destination pointer we want to write to

	label Sprite_Assign_Loop;
	HL = SP + $05;	# Pointer to Y value
	A = [DE];		# Gets delta Y
	DE++;			# next delta
	A += [HL];		# Adds Y value
	HL--;			# next stack val
	[BC] = A;		# Assigns Y value of sprite
	C++;			# Increments destination pointer

	A = [DE];		# Gets delta X
	DE++;			# next sprite data
	A += [HL];		# Adds X value
	HL--;			# next stack val
	[BC] = A;		# Assigns X value of sprite
	C++;			# Increments destination pointer

	A = [DE];		# Gets sprite tile
	DE++;			# Next sprite data
	[BC] = A;		# Sets sprite tile
	C++;			# increments destination pointer
	A = [HL--];		# Gets sprite flags
	[BC] = A;		# Sets sprite flags
	C++;			# Increments destination pointer

	[HL]--;			# Decrements counter
	jump not_zero Sprite_Assign_Loop;

	pop HL;		# Gets function pointer, reduces stack
	SP += $04;	# This is done to reduce the stack to where it was before 
	
	# (we don't need to grab the values to any register, saving time)

	jump HL;	# Returns
}

#

subroutine Window_Hide_LCD_Routine $0720
{
	A = $FF;								# 0710 - 0711
	[$FF00 + WINDOW_SCROLL_X_REGISTER] = A;	# 0712 - 0713

	A ^= A;									# 0714

	[$FF00 + LCD_STATUS_REGISTER] = A;		# 0715 - 0716

	pop HL;									# 0717

	returni;								# 0718
}

subroutine Title_Screen_LCD_Interrupt_Routine $06FA
{
	A = [$FF00 + LCD_STATUS_REGISTER];		
	A &= $02;								
	jump not_zero Window_Hide_LCD_Routine;	

	HL = Frame_Counter_Register;

	A = [$FF00 + LCDY_REGISTER];
	A += [HL];
	swap A;
	A <<>= 1;
	A &= $0F;
	
	jump not_zero Local_Conditional_Add;	

	A++;		

	label Local_Conditional_Add;

	call Triangle_Wave;

	# A &= $0F;

	A += $02;

	[$FF00 + WINDOW_SCROLL_X_REGISTER] = A;	

	pop HL;									
	returni;							
}

subroutine LCD_Jump $0048
{
	push HL;
	HL = LCD_Interrupt_Routine_Flags;
	[HL].0;
	jump Title_Screen_LCD_Interrupt_Routine;
}

subroutine Init_Title_Screen_Sprites $0990
{
	HL = OAM_Buffer_Counter;
	A ^= A;
	[HL] = A;

	BC = $1008;	# Y and X position
	push BC;
	BC = Title_Text_Left_Pad_Graphics_Size;	# Sprite flags and number of sprites
	push BC;
	DE = Title_Text_Left_Pad;
	call Place_Meta_Sprite_In_OAM;

	return;
}

subroutine Title_Screen_VBlank_Routine $0930
{
	# We want all of the title screen logic to occur during VBlank
	# this is because while the PPU is drawing, the HBlank routines
	# are fairly demanding

	A = $48;
	
	[$FF00 + LCD_STATUS_REGISTER] = A;

	A = $10;
	[$FF00 + WINDOW_SCROLL_Y_REGISTER] = A;

	A = $07;
	[$FF00 + WINDOW_SCROLL_X_REGISTER] = A;

	HL = Frame_Counter_Register;
	[HL]++;

	A = [HL];

	A >>>= 1;

	[$FF00 + BACKGROUND_SCROLL_X_REGISTER] = A;

	A >>>= 1;
	A >>>= 1;

	[$FF00 + BACKGROUND_SCROLL_Y_REGISTER] = A;

	A = Title_Text_Left_Pad_Graphics_Size;
	[OAM_Buffer_Counter] = A;			# Resets OAM buffer counter
	
	push BC;
	call DMA_Transfer;
	pop BC;

	pop HL;

	returni;
}

subroutine VBlank_Handler $07F0
{
	push HL;							# 0000
	HL = VBlank_Interrupt_Routine_Flags;# 0001 - 0003
	[HL].0;								# 0004 - 0005
	# jump 

	jump Title_Screen_VBlank_Routine;	# 0006 - 0008

	returni;							# 0009
}

subroutine VBlank_Jump $0040
{
	jump VBlank_Handler;
}